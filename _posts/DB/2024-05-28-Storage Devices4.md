---
title: File Organization
date: 2024-05-28 13:59
category: DB
tags: [Storage Devices]
summary: File Organization은 데이터베이스에서 파일을 저장하고 접근하는 방법을 결정하는 것을 의미합니다. 파일 구조, 색인, 클러스터링 등의 기법을 사용하여 파일을 효율적으로 저장하고 접근할 수 있습니다.
toc: true
toc_sticky: true
---

# File/Record Organization
파일 구조(File Organization)는 데이터베이스에서 파일을 저장하고 접근하는 방법을 결정하는 것을 의미합니다. 파일 구조는 데이터베이스의 성능과 효율성에 큰 영향을 미치며, 이를 효율적으로 설계하면 데이터베이스의 성능을 향상시킬 수 있습니다.

파일은
- **레코드(Record)**로 구성되며,
- 레코드는 **필드(Field)**로 구성됩니다.

## Fixed-Length Records
고정 길이 레코드는 고정된 길이의 필드로 구성된 레코드를 의미합니다. 레코드의 길이가 일정하므로 레코드의 위치를 쉽게 계산할 수 있습니다.
> 각 필드는 고정된 길이를 가지며, 레코드의 전체 길이는 모든 필드의 길이의 합과 같습니다.

### 레코드 $i$의 저장
**레코드 $i$를 $n \times (i-1)$바이트에서부터 저장**합니다. (여기서 $n$은 레코드의 크기)

> 예를 들어, 레코드의 크기가 $n$바이트라면
- 첫번째 레코드는 0바이트부터 $n-1$바이트까지,
- 두번째 레코드는 $n$바이트부터 $2n-1$바이트까지
- 세번째 레코드는 $2n$바이트부터 $3n-1$바이트까지 
- 이렇게 계속됩니다.
{: .notice--warning}


### 레코드 $i$의 삭제

고정 길이 레코드를 삭제할 때, 아래와 같은 세 가지 방법을 사용할 수 있습니다:

**레코드 $i + 1$부터 $n - 1$까지의 레코드를 $i$로 이동**

이 방법은 삭제된 레코드 뒤에 있는 모든 레코드를 앞으로 한 칸씩 이동시키는 방법입니다. <br>예를 들어, 레코드 3을 삭제하면 레코드 4가 레코드 3의 위치로 이동하고, 레코드 5가 레코드 4의 위치로 이동하는 식입니다.<br>이 방법은 데이터의 연속성을 유지하지만, 많은 레코드를 이동시켜야 하므로 비효율적일 수 있습니다.
{: .notice--info}

**레코드를 삭제하고 뒤에 있는 레코드를 앞으로 이동**

이 방법은 마지막(맨 끝에 있는) 레코드를 삭제된 레코드의 위치로 이동시키는 방법입니다.
예를 들어, 레코드 3을 삭제하면 마지막 레코드가 레코드 3의 위치로 이동합니다.
이 방법은 이동할 레코드의 수를 최소화하지만, 레코드의 순서가 뒤바뀔 수 있습니다.
{: .notice--info}
    
**레코드를 삭제하고 뒤에 있는 레코드를 앞으로 이동하고, 마지막 레코드를 삭제한 레코드로 채움**

이 방법은 삭제된 레코드의 위치를 그대로 두고, 해당 위치를 자유 목록(free list)에 추가하는 방법입니다.
free list는 삭제된 레코드들의 위치를 추적하는 리스트로, 새로운 레코드를 저장할 때 이 리스트를 참조하여 빈 공간을 재사용할 수 있습니다.
이 방법은 레코드를 이동시키지 않아도 됩니다. **하지만**, 레코드를 이동시키지 않고 삭제된 레코드를 free list로 연결하는 방법은 파일에 너무 많은 hole(빈 공간)이 생길 수 있습니다.
{: .notice--info}

이 문제를 해결하기 위해서는 주기적으로 파일을 압축(compaction)하여 조각화를 줄이는 작업이 필요합니다. 압축 과정은 삭제된 레코드들을 제거하고 남은 레코드들을 연속적으로 재배치하여 파일 내 연속된 자유 공간을 확보하는 방법입니다. 이를 통해 파일의 성능을 유지할 수 있습니다.

따라서, 자유 목록을 사용하는 방법은 구현이 간단하고 효율적일 수 있지만, 장기적으로 파일의 성능을 유지하기 위해서는 정기적인 파일 압축이 필요합니다.