---
title: Recovery
date: 2024-04-23 00:47
category: DB
tags: [DB, Recovery]
summary: 데이터베이스 시스템에서 발생하는 장애와 회복 기법에 대해 알아봅니다.
toc: true
toc_sticky: true
---

# Failures and Recovery
## Failure Classification

데이터베이스 시스템이 처리하는 장애는 크게 3가지로 분류할 수 있습니다.
1. Transaction Failures
    - Logical Errors : 트랜잭션 내부에서 발생하는 오류, 사용자의 명시적인 요구
    - System Errors : 시스템 내부 결정에 의한 오류(예: Deadlock 발생으로 인한 특정 트랜잭션 철회
2. System Failures : Memory 내용이 사라지는 문제(예: 정전, OS 오류, 하드웨어 결함 등)
3. Disk Failures : Disk 내용이 사라지는 문제(예: 하드웨어 결함)

시스템이 처리하고자 하는 이러한 장애들은 예고 없이 발생할 수 있습니다. 이러한 장애가 발생하는 경우, 시스템을 복구하기 위해 Recovery 기법을 사용합니다.

## Recovery Algorithms
회복 알고리즘은 크게 2가지로 분류할 수 있습니다.
1. 정상 상태에서 시스템 회복을 대비하기 위하여 수행하는 연산 : ex) Checkpointing
2. 장애가 발생하였을 때 회복하기 위하여 수행하는 연산 : ex) REDO, UNDO

## Stable storage
Stable storage는 어떠한 장애가 발생하여도 저장 내용이 상실되지 않는 가상적인 저장소입니다. 이러한 가정을 통해 데이터베이스 시스템은 장애가 발생하더라도 데이터의 무결성을 보장할 수 있습니다. 

현실적으로는 안정 저장 매체로 RAID 시스템을 사용합니다. RAID 시스템은 여러 개의 디스크에 저장 내용을 중복하여 저장하고 분산하여 저장하는 방식으로 안정성을 높이는 기술입니다.

## Data Location
데이터베이스 시스템에서는 동일 데이터가 3군데 위치에 존재할 수 있습니다. 이러한 데이터 위치는 다음과 같습니다.

    1. Main Memory
        - Process memory(work area)
        - Buffer blocks
    2. Disk
        - Disk blocks

데이터 버퍼와 프로세스 메모리 영역은 메인 메모리 내에 존재하므로, 메인 메모리가 고장이 나는 경우에는 데이터가 손실되나, 디스크에 존재하는 데이터는 손상이 없습니다. 

데이터베이스 시스템에서 프로세스 고유 영역에서 버퍼 블록으로 데이터를 이동하는 것은 데이터베이스 관리 시스템 또는 사용자의 요청에 따라 이루어집니다. **하지만** 버퍼 블록에서 디스크 블록으로 데이터를 이동하는 것은 운영체제의 역할입니다.

데이터베이스 사용자가 데이터 쓰기를 완료하는 것은 버퍼 블록에 데이터를 쓰는 것임을 알아야 합니다. 즉, 쓰기가 완료된 후에 시스템 장애가 발생하면 디스크에는 아직 데이터 갱신이 반영되지 않을 수도 있습니다.

![Data Location]({{"/assets/images/recovery/1.png" | relative_url}}){: .align-center width="70%"}

데이터는 기본적으로 **디스크**에 존재하며, DBMS에 의하여 필요 시에 **시스템 버퍼**에 블록 단위로 복사될 수 있습니다. (디스크→시스템버퍼 복사) <br>
**시스템 버퍼**에 있는 데이터를 사용자 트랜잭션이 직접 사용하지 않으며, 사용자가 데이터를 접근하려면 해당 **사용자 메모리**로 데이터를 복사(read 연산)해 와서 접근합니다. (시스템버퍼→사용자메모리 복사)

사용자는 사용자 영역에 있는 데이터를 접근하며, 데이터 갱신을 하는 경우 **시스템 버퍼**에 존재하는 데이터 값과 **사용자 메모리**에 존재하는 데이터 값이 상이할 수 있습니다.

사용자가 write 연산을 이용하여 **사용자 메모리**에 있는 데이터를 **시스템 버퍼**에 복사할 수 있습니다. (사용자메모리→시스템버퍼 복사)

결론

세 군데 존재하는 데이터 값이 모두 상이할 수도 있으나, 가장 정확한(또는 최근에 갱신된) 데이터 값은 **사용자 메모리**에 존재하는 데이터 값입니다.
{: .notice--info}

# Logs
회복 기법은 크게 두 가지 방법이 존재하며, 그 중에서 로그 방식이 상용 DBMS에서 많이 사용됩니다. 로그는 데이터베이스 시스템에서 발생하는 모든 변경 사항을 기록하는 파일입니다. 로그 파일은 안정 저장 매체에 저장되어야 하며, 데이터베이스 시스템이 장애가 발생하였을 때 로그 파일을 이용하여 데이터베이스 시스템을 복구합니다.

로그 방식에서는 DB에 변화가 발생하기 **전에** 로그 파일에 변경 사항을 기록해야 합니다. 이러한 방식을 **Write-Ahead Logging**(WAL) 이라고 합니다.

로그 파일은 크게 두 가지로 분류할 수 있습니다.
1. log-based recovery
2. shadow paging

## shadow paging
shadow paging은 데이터베이스의 모든 페이지를 복사하여 변경 사항이 발생할 때마다 새로운 페이지를 생성하는 방식입니다. 이러한 방식은 로그 방식에 비해 비효율적이지만, 로그 방식에 비해 복구 시간이 빠르다는 장점이 있습니다.

그림자 기법은 오래전에 사용되었던 기법으로 요사이는 데이터베이스 환경에서는 사용하지 않습니다. 
## Log-based Recovery
로그 기반 회복은 데이터베이스 시스템에서 발생하는 모든 변경 사항을 로그 파일에 기록하는 방식입니다. 

### Simple Logging: Normal Processing
로깅을 함에 있어 구체적으로 어떤 값을 어떤 방식으로 기록하는가는 여러 가지 방식이 있습니다.
1. `<Ti start>` : 트랜잭션 Ti가 시작됨을 기록
2. `<Ti, X, old, new>` : 트랜잭션 Ti가 데이터 X의 값을 old에서 new로 변경함을 기록
3. `<Ti commit>` : 트랜잭션 Ti가 종료됨을 기록

디스크와 메인메모리 간의 데이터 이동이 블록 단위로 이루어졌듯이, 로그 레코드를 디스크에 기록할 때도 블록 단위로 이루어집니다. 

![Simple Logging]({{"/assets/images/recovery/2.png" | relative_url}}){: .align-center width="70%"}

트랜잭션은 동시에 다수가 실행되므로, 로그 블록 하나 내에는 여러 트랜잭션의 로그 레코드가 존재할 수 있습니다.
{: .notice--info}

### Simple Logging: Checkpoint
Checkpoint는 데이터베이스 시스템이 정상적으로 동작하고 있는 시점을 기록하는 것입니다. Checkpoint는 데이터베이스 시스템이 장애가 발생하였을 때, 복구를 위한 기준점으로 사용됩니다.

Checkpointing(검사점 연산)은 기본적으로 주기억장치(Memory)에 존재하는 모든 로그 레코드와 변경된 데이터 페이지를 디스크에 반영하여, <br> (디스크에 저장되어 있는) 데이터 상태와 (주기억장치에 저장되어 있는) 데이터 상태를 동일하게 하는 연산입니다.

### Simple Logging: Recovery
시스템 장애기 발생하면, 로그와 디스크에 저장된 데이터만 존재하므로 이를 이용하여 시스템 회복을 하여야 합니다. 로그 기반 회복은 크게 두 가지로 분류할 수 있습니다.

1. UNDO - 시스템 장애가 발생하였을 때, 로그를 이용하여 변경된 데이터를 **원래 상태로 되돌리는** 방식
2. REDO - 시스템 장애가 발생하였을 때, 로그를 이용하여 변경된 데이터를 **디스크에 반영**하는 방식

UNDO를 먼저 수행하고, REDO를 수행하는 방식으로 회복을 수행합니다. (상식적으로 생각해보면, REDO한 뒤에 UNDO를 수행하면 REDO한 것이 무의미해지기 때문입니다.)

# Buffer Management
데이터베이스 시스템이 버퍼를 사용하는 이유는 디스크와 메인 메모리의 속도 차이 때문입니다. 디스크는 메인 메모리에 비해 속도가 느리기 때문에, 디스크에 있는 데이터를 메인 메모리에 복사하여 사용자가 데이터에 접근할 때 빠르게 접근할 수 있도록 합니다.

해당 섹션에서는 이 버퍼를 어떻게 관리하는지에 대해 다룹니다.
{: .notice--info}

버퍼 관리에서 가장 중요한 것은 **버퍼 교체 정책**입니다. 버퍼 교체 정책은 버퍼에 있는 데이터 중 어떤 데이터를 버릴지 결정하는 정책입니다.
선택된 버퍼는 더 이상 메모리 버퍼 공간을 차지하지 않게 됩니다. (단, 그 블록 내용이 변경되었으면 디스크에 그 내용을 반영해야 합니다)

가장 널리 사용되는 방식은 LRU(Least Recently Used) 방식입니다. LRU 방식은 가장 오랫동안 사용되지 않은 데이터를 버퍼에서 제거하는 방식입니다.

LRU 방식의 기본 아이디어는 블록에 대한 과거 접근 패턴이 미래에도 적용될 것이라는 가정입니다. 이 가정은 대부분의 경우에 유효하지만, 특정 상황에서는 잘못된 결정을 내릴 수 있습니다. <br>
LRU 방식이 데이터베이스 환경에서 적절하지 않다는 지적은 문헌에 많이 나와 있으나, 아직까지 이를 대체하는 효과적인 버퍼 교체 방식이 없는 것도 사실입니다.
{: .notice--info}

LRU 버퍼 교체 정책 외에도 다양한 버퍼 교체 정책이 존재합니다.
1. Pinned block
2. Toss-immediate strategy
3. MRU(Most Recently Used) strategy

## Data Page Buffering 
데이터베이스 시스템에서는 데이터를 페이지 단위로 관리합니다. 디스크에 있는 데이터를 메인 메모리에 복사할 때(Buffering)도 **페이지** 단위로 복사합니다.

Data Block을 Disk에 쓸 때 해당 블록이 교체되버리면 안되므로, 이를 위하여 latch를 사용합니다. latch는 데이터 블록을 메모리에 쓸 때, 해당 블록이 다른 블록에 의해 교체되지 않도록 하는 기능입니다.

latch와 lock은 다른 개념입니다. **latch**는 운영체제가 지원하는 기능으로서 데이터 블록을 메모리에 쓸 때, 해당 블록이 다른 블록에 의해 교체되지 않도록 하는 기능입니다. <br>
반면 **lock**은 데이터베이스 시스템이 지원하는 기능으로서 데이터 블록을 메모리에 쓸 때, 해당 블록이 다른 트랜잭션에 의해 접근되지 않도록 하는 기능입니다.
{: .notice--warning}

DB buffer 구현은 크게 두 가지 방식으로 구현할 수 있습니다.
1. Real main-memory buffer
2. Virtual memory buffer

보통 DB buffer는 2번 방식으로 구현합니다. 이는 DB buffer가 메인 메모리에 존재하지 않더라도, DB buffer에 있는 데이터를 메인 메모리에 복사할 수 있기 때문입니다. 이 경우 Dual paging 문제가 발생하지 않는다는 장점이 있습니다.

Dual paging 문제는 데이터베이스 시스템이 특정 블록을 디스크에 output 하려고 할 때 해당 블록이 이미 디스크 swap 영역에 존재하여 이를 메모리 상으로 input한 후 이를 다시 디스크에 output하는 현상을 말합니다.
{: .notice--info}

## Slotted Page Structure

## Steal vs. Force Policy